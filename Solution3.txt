Answer following questions

1. A JOIN is more efficient in most cases, but there are cases in which constructs other than a subquery is not possible.
While subqueries may be more readable for beginners, JOINS are more readable for experienced SQL coders as the queries become more 
complex. It is a good practice to avoid multiple levels of nested subqueries, since they are not easily readable and do not have good performance. It is better to write a query with JOINS rather than subqueries.

2. CTE's stand for Common Table Expressions Count. The main purpose of using them are to be able to write recursive queries. 
They are also applied for temporary views. They help in improving readability and manageability of complex SQL statements.

3. Table variables are used as a replacement of temporary tables when the data set is not very large. It is a data type that can be used within a Transact-SQL batch, stored procedure, or function - it is created and defined similarly to a table, only with a 
strictly defined lifetime scope. They can't have indexes or Foreign Key constraints added to them. Some constraints like Primary Key, Unique and Check can be applied to them. 

They improve performance and don't occupy unwanted disk space like temporary tables, hence are useful.

4. a. Truncate removes all the records, delete is used for deleting specific data
b. Truncate is faster than delete
c. Truncate is not possible when a table is referenced by a foreign key or tables are replicated or with indexed views.
d. You can rollback a delete command, not a truncate command.

5. An identity column is a column (also known as a field) in a database table that is made up of values generated by the database.
Truncate reseeds identity values, whereas delete doesn't.

6. The delete statement removes rows one at a time and records an entry in the transaction log for each deleted row. 
Truncate table removes the data by deallocating the data pages used to store the table data and records only the page deallocations
in the transaction log.


Write queries for following scenarios

1. SELECT City FROM Employees WHERE City IN (SELECT City FROM Customers);

2. a. SELECT City FROM Customers WHERE City NOT IN (SELECT City FROM Employees);

2. b. 

3. 
SELECT p.ProductName, SUM(od.Quantity)
FROM Products p 
FULL JOIN 
[Order Details] od 
ON p.ProductID = od.ProductID
GROUP BY p.ProductName;

4. 
SELECT c.City, SUM(od.Quantity) 'Qty'
FROM Customers c 
LEFT JOIN 
Orders o
ON c.CustomerID = o.CustomerID
LEFT JOIN 
[Order Details] od
ON o.OrderID = od.OrderID
GROUP BY c.City;

5. 
SELECT City, COUNT(CustomerID) 'CustomerCount' 
FROM Customers 
GROUP BY City 
HAVING COUNT(CustomerID) > 2
UNION
SELECT City, COUNT(CustomerID) 'CustomerCount' 
FROM Customers 
GROUP BY City 
HAVING COUNT(CustomerID) > 2;

6. 


8. 
SELECT TOP 5 od.Quantity, od.ProductID, p.ProductName, AVG(p.UnitPrice) 'Avg'
FROM [Order Details] od 
FULL JOIN Products p 
ON od.ProductID = p.ProductID
GROUP BY od.Quantity, od.ProductID, p.ProductName;
	
11. Use a CTE with a row number as both combined allow us to see which rows are deleted. 
WITH CTE AS(
   SELECT [col1], [col2], [col3], [col4], [col5], [col6], [col7],
       RN = ROW_NUMBER()OVER(PARTITION BY col1 ORDER BY col1)
   FROM dbo.Table1
)
DELETE FROM CTE WHERE RN > 1;


12. SELECT * FROM Employee WHERE mgrid IS NULL;

13. SELECT COUNT(e.empid), d.deptname FROM Department d LEFT JOIN Employee e ON e.deptid = d.deptid GROUP BY d.deptname HAVING COUNT(e.empid) ASC;
   